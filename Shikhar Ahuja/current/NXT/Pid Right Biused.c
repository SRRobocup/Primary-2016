#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S2,     ,               sensorLightActive)
#pragma config(Sensor, S3,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LM motorA
#define RM motorC

#include "myLib.c"


float currErr, prevErr; // actual errors value
float pGain, dGain;   // tuned value
float kp =6;//kp 5.25
float kd = 1.8;//kd 1.4
int white=71, black=42, tp=30;//tp=30
int threshold = (white+black)/2 ;
int darkb=48,lightb=78;
int bthreshold=(darkb+lightb)/2;
int silver=83;
int silverthreshold=(white+black)/2;
void RIPID()
{
	{
		currErr = threshold-SensorValue[S1];
		pGain = currErr * kp;

		prevErr = currErr;
		dGain = (currErr - prevErr) *kd;
		motor[LM] = tp + pGain + dGain;
		motor[RM] = tp - pGain - dGain;

		displayTextLine(2,"L: %d", motor[LM]);
		displayTextLine(4,"R: %d", motor[RM]);
		displayTextLine(6,"%.2f", pGain);
		displayTextLine(3,"%.2f", currErr);
	}
}

void ObStA()
{
	float bz=.3, dia=10, wb=14, inner=dia+(bz*2), outer=inner+(wb*2);
	float opow=100, ipow=opow*(inner/outer);
	// this is the initializing
	motor[LM]= 0;
	motor[RM]= 0;
	playSound(soundBlip);
	wait10Msec(100);
	turnleft(90);

	motor[LM]=0;
	motor[RM]=0;
	playSound(soundBeepBeep);
	wait10Msec(100);
	if (SensorValue[S4]>10)
	{
		wait10Msec(10);
		motor[RM]=opow;
		motor[LM]=ipow;
		while(SensorValue[S1]>threshold)
		{
			displayCenteredBigTextLine(2,"L: %d",motor[LM]);
			displayCenteredBigTextLine(4,"R: %d",motor[RM]);

		}
		motor[LM]=0;
		motor[RM]=0;
		wait10Msec(10);
	}
	else
	{
		playSound(soundFastUpwardTones);
		turnright(180);
		wait10Msec(10);
		motor[LM]=opow;
		motor[RM]=ipow;

		while(SensorValue[S1]>threshold-10)
		{
			displayCenteredBigTextLine(2,"L: %d",motor[LM]);
			displayCenteredBigTextLine(4,"R: %d",motor[RM]);
		}

		motor[LM]=0;
		motor[RM]=0;
		wait10Msec(10);

		motor[LM]=0;
		motor[RM]=40;

		while(SensorValue[S1]>threshold+8)
		{
			wait1Msec(30);
		}

		motor[LM]=0;
		motor[RM]=40;

		while(SensorValue[S1]<threshold-8)
		{
			wait1Msec(30);
		}

	}
}

task Wobble()
{
	//the function crossing the gap
	while (1!=4)
	{

		gostraight(4);

		turnright(38);

		gostraight(4);

		turnleft(38);

	}
}

void gap(int Encoder)
{// the function which prepares for gap
	displayTextLine(0,"check gap worked");
	PlaySound(soundFastUpwardTones);
	nMotorEncoder[motorA]=0;
	while(nMotorEncoder[motorA]<Encoder)
	{
		motor[Rm]=-30;
		motor[Lm]=30;
	}
	Stop();
	wait1Msec(1000);
	startTask(Wobble);
	while(SensorValue[S1]>threshold)
	{
		nxtDisplayTextLine(7,"%d",SensorValue[S1]);
	}
	stopTask(Wobble);
}

void checkgap()
{
	//the function sensing that it is a gap
	if (SensorValue[S1]>threshold+5)
	{
		//the else must not be met if the first condition is met, and the second is not
		if(abs(nMotorEncoder[motorC])>2250)//2000
		{
			int EncoderVal = nMotorEncoder[motorC];
			nMotorEncoder[motorC]=0;
			Stop();
			wait10Msec(30);
			gap(EncoderVal);
		}
	}
	else
	{
		nMotorEncoder[motorC] = 0;
	}
}

void intersection()
{

	if (SensorValue[S3]<bthreshold-5)
	{
		playSound(soundLowBuzz);
		gostraight(6);
		wait1Msec(750);
		if (SensorValue[S1]<threshold)
		{
			wait1Msec(750);
			return;
		}
		else
		{
			wait1Msec(750);
			while (SensorValue[S1]>black)
			{
				motor[LM]=-40;
				motor[RM]=-40;
			}
			goback(1);
			RIPID();
			wait10Msec(100);
		}

	}

}

task main()
{
	wait1Msec(50);
	while(SensorValue[S1]<84)
	{
		if(SensorValue[S4]<8)
		{
			gostraight(2);
			ObStA();
		}

		else
		{
			//	intersection();
			checkgap();
			RIPID();
		}
	}
}
